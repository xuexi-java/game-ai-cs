## 1. 整体接入流程
```text
玩家
  │
  │ 0. 点击 客服中心
  ▼
游戏客户端
  │
  │ 1. 向游戏服请求客服URL
  ▼
游戏服务器
  │
  │ 2. 按规则拼接客服URL
  ▼
游戏客户端
  │
  │ 3. 根据客服URL,打开对应客服前端
  ▼
客服页面
```
## 2. 核心数据协议  
  
### 2.1 认证接口定义 (游戏客户端向游戏服务器)  
#### 请求参数  
| 字段名      | 类型     | 必填  | 说明        |     |
| :------- | :----- | :-- | :-------- | --- |
| `uid`    | String | 是   | 玩家唯一 ID   |     |
| `areaid` | String | 是   | 玩家所在区服 ID |     |
  
#### 成功响应示例
```json
{
  "success": true,
  "data": {
	  "gameid": "10001",
	  "uid": "player_001",
	  "areaid": "1",
	  "playerName": "测试玩家",
	  "ts": 1737003600000,
	  "nonce": "n7k9m2x4p6q8w3e5",
	  "sign": "981efc6fd37795c635fb038c6b466d6d",
	  "h5Url": "https://cs-web.yourgame.com"
	  }
}  
```  
  
---  
  
### 2.2 认证参数字段说明 (服务器端)
gameid 映射参考：  
- 新弹弹堂: "10001"  
- 弹弹堂大冒险: "10002"  
- 页游弹弹堂: "10003"  
  
| 参数名          | 类型     | 说明                                      |     |
| :----------- | :----- | :-------------------------------------- | --- |
| `gameid`     | String | 游戏标识                                    |     |
| `uid`        | String | 玩家唯一 ID                                 |     |
| `areaid`     | String | 玩家所在区服                                  |     |
| `playerName` | String | 玩家昵称                                    |     |
| `ts`         | Long   | 生成签名的时间戳 (毫秒)                           |     |
| `nonce`      | String | 固定随机串                                   |     |
| `sign`       | String | 服务器计算好的签名                               |     |
| `h5Url`      | String | 客服前端部署地址                                |     |
| platform     | Sting  | 来自什么端(如:Android\H5\iOS\mini_wx\mini_dy) |     |

  
---  
  
### 2.3 URL 拼接规则（游戏客户端）  
当前采用 URL 传参模式，游戏客户端需要拼接完整 URL 并打开 WebView。  
**最终 URL 拼接示例**：  
`{h5Url}[/]?gameid={gameid}&uid={uid}&areaid={areaid}&ts={ts}&nonce={nonce}&sign={sign}&playerName={PlayerName}&platform=android 
  
---  
  
## 3. 签名计算规则(服务器端)     
*   **算法**：`MD5`
*   **公式**：`sign = md5(gameid|uid|areaid|ts|nonce|secret).toLowerCase()`
* 例:
* `sign = md5(10001 + "|" + player002+ "|" +1+ "|" + 1737003600000 + "|" +"n7k9m2x4p6q8w3e5"+ "|" + "s3cr3t_k7m9n2p4q6x8w1e5r0t2y4u6").toLowerCase()`
* sign = "8149c825a2f85d7a034cda231f10903d"
计算示例

| 参数     | 值                                |
| ------ | -------------------------------- |
| gameid | 10001                            |
| uid    | player002                        |
| areaid | 1                                |
| ts     | 1737003600000                    |
| nonce  | n7k9m2x4p6q8w3e5                 |
| secret | s3cr3t_k7m9n2p4q6x8w1e5r0t2y4u6  |
| sign   | 8149c825a2f85d7a034cda231f10903d |

---  
  
## 4. 各平台接入示例与权限配置

### 4.1 Android 平台

#### 4.1.1 权限声明 (`AndroidManifest.xml`)
```xml
<!-- 网络权限 -->
<uses-permission android:name="android.permission.INTERNET" />
<!-- 相册权限 (Android 13+) -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
```

#### 4.1.2 接入代码 (Kotlin)
```kotlin
/**  
 * 表示签名参数 API 响应的数据类。  
 */  
data class SignedParamsResponse(val success: Boolean, val data: SignedParams?, val error: String?)  
  
/**  
 * 包含游戏/H5 身份验证和会话参数的数据类。  
 */  
data class SignedParams(  
    val h5Url: String,  
    val gameid: String,  
    val uid: String,  
    val areaid: String,  
    val playerName: String,  
    val ts: Long,  
    val nonce: String,  
    val sign: String  
)  
  
/**  
 * MainActivity 处理 Mock Player 应用程序的核心逻辑。  
 * 它从服务器获取验证参数，并在 WebView 中显示游戏/客服 H5 页面，同时提供 JavaScript Bridge 交互功能。  
 */  
class MainActivity : AppCompatActivity() {  
  
    private lateinit var webView: WebView  
    private lateinit var progressBar: ProgressBar  
    private var fileChooserCallback: ValueCallback<Array<Uri>>? = null  
  
    /**  
     * 存储当前玩家的签名参数，通过 JavaScript Bridge 与 H5 共享。  
     */  
    private var currentParams: SignedParams? = null  
  
    private val client = OkHttpClient()  
    private val gson = Gson()  
  
    companion object {  
        private const val FILE_CHOOSER_REQUEST_CODE = 1001  
        private const val TAG = "MockPlayer"  
    }  
  
    /**  
     * 获取客服身份验证参数的接口地址。  
     * 注意：10.0.2.2 是从 Android 模拟器访问宿主机 localhost 的默认 IP。  
     */  
    private val GAME_SERVER_URL = "http://10.0.2.2:3001/api/get-cs-auth"  
  
    override fun onCreate(savedInstanceState: Bundle?) {  
        super.onCreate(savedInstanceState)  
        supportActionBar?.hide()  
        setContentView(R.layout.activity_main)  
  
        webView = findViewById(R.id.webView)  
        progressBar = findViewById(R.id.progressBar)  
  
        // 处理沉浸式状态栏及系统栏间距  
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->  
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())  
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)  
            insets  
        }  
  
        setupWebView()  
        // 示例：启动时请求特定玩家的签名参数  
        requestSignedParams("player001", "1")  
    }  
  
    /**  
     * 获取用户的签名参数，然后加载 H5 页面。  
     * @param uid 用户唯一 ID。  
     * @param areaid 区服 ID。  
     */  
    private fun requestSignedParams(uid: String, areaid: String) {  
        progressBar.visibility = View.VISIBLE  
        lifecycleScope.launch {  
            try {  
                val result = fetchAuthFromServer(uid, areaid)  
                if (result != null && result.success && result.data != null) {  
                    currentParams = result.data  
                    loadCustomerServiceUrl(result.data)  
                } else {  
                    val msg = result?.error ?: "数据解析失败"  
                    showError("获取签名失败: $msg")  
                }  
            } catch (e: Exception) {  
                showError("网络请求异常: ${e.message}")  
            }  
        }  
    }  
  
    /**  
     * 从后端服务器获取验证数据的网络请求。  
     */  
    private suspend fun fetchAuthFromServer(uid: String, areaid: String): SignedParamsResponse? = withContext(Dispatchers.IO) {  
        val json = gson.toJson(mapOf("uid" to uid, "areaid" to areaid))  
        val body = json.toRequestBody("application/json".toMediaType())  
        val request = Request.Builder().url(GAME_SERVER_URL).post(body).build()  
  
        try {  
            client.newCall(request).execute().use { response ->  
                val bodyStr = response.body?.string()  
                Log.d(TAG, "Server Response: $bodyStr")  
                if (!response.isSuccessful) return@withContext null  
                gson.fromJson(bodyStr, SignedParamsResponse::class.java)  
            }  
        } catch (e: Exception) {  
            Log.e(TAG, "Fetch Error", e)  
            null  
        }  
    }  
  
    /**  
     * 初始化 WebView 设置，配置 JavaScript 接口，并处理 ChromeClient/WebViewClient 事件。  
     */  
    @SuppressLint("SetJavaScriptEnabled")  
    private fun setupWebView() {  
        webView.settings.apply {  
            javaScriptEnabled = true  
            domStorageEnabled = true  
            allowFileAccess = true  
            mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW  
        }  
  
        // 将 Bridge 以 'AndroidBridge' 的名称暴露给 JavaScript        webView.addJavascriptInterface(object {  
            @JavascriptInterface  
            fun close() = runOnUiThread { finish() }  
  
            /**  
             * 向 H5 环境提供当前玩家信息。  
             */  
            @JavascriptInterface  
            fun getPlayerInfo(): String {  
                val json = currentParams?.let { gson.toJson(it) } ?: "{}"  
                Log.d(TAG, "JS Bridge 调用 getPlayerInfo: $json")  
                return json  
            }  
        }, "AndroidBridge")  
  
        webView.webChromeClient = object : WebChromeClient() {  
            /**  
             * 处理 WebView 发起的选择文件请求（例如在客服聊天中上传图片）。  
             */  
            override fun onShowFileChooser(webView: WebView?, callback: ValueCallback<Array<Uri>>?, params: FileChooserParams?): Boolean {  
                fileChooserCallback?.onReceiveValue(null)  
                fileChooserCallback = callback  
                val intent = Intent(Intent.ACTION_PICK).apply { type = "image/*" }  
                startActivityForResult(intent, FILE_CHOOSER_REQUEST_CODE)  
                return true  
            }  
        }  
  
        webView.webViewClient = object : WebViewClient() {  
            override fun onPageFinished(view: WebView?, url: String?) {  
                progressBar.visibility = View.GONE  
            }  
  
            override fun onReceivedError(view: WebView?, request: WebResourceRequest?, error: WebResourceError?) {  
                super.onReceivedError(view, request, error)  
                runOnUiThread {  
                    Toast.makeText(this@MainActivity, "加载失败: ${error?.description}", Toast.LENGTH_LONG).show()  
                }  
            }  
        }  
    }  
  
    /**  
     * 构造带有查询参数的最终 URL 并在 WebView 中加载。  
     */  
    private fun loadCustomerServiceUrl(params: SignedParams) {  
        val url = buildString {  
            append(params.h5Url)  
            if (!params.h5Url.contains("?")) append("/")  
            append("?gameid=${params.gameid}")  
            append("&uid=${params.uid}")  
            append("&areaid=${params.areaid}")  
            append("&ts=${params.ts}")  
            append("&nonce=${params.nonce}")  
            append("&sign=${params.sign}")  
            append("&playerName=${URLEncoder.encode(params.playerName, "UTF-8")}")  
            append("&platform=android")  
        }  
        Log.d(TAG, "Loading URL: $url")  
        webView.loadUrl(url)  
    }  
  
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {  
        super.onActivityResult(requestCode, resultCode, data)  
        if (requestCode == FILE_CHOOSER_REQUEST_CODE) {  
            fileChooserCallback?.onReceiveValue(if (resultCode == RESULT_OK) data?.data?.let { arrayOf(it) } else null)  
            fileChooserCallback = null  
        }  
    }  
      
    override fun onDestroy() {  
        webView.destroy()  
        super.onDestroy()  
    }  
  
    /**  
     * 向用户显示错误消息并隐藏加载进度条。  
     */  
    private fun showError(msg: String) {  
        progressBar.visibility = View.GONE  
        Toast.makeText(this, msg, Toast.LENGTH_LONG).show()  
    }  
}
```
---
### 4.2 iOS 平台


---

### 4.3 Flash / 网页平台 (Iframe 嵌入)

#### 4.3.1 接入代码
```html
<!DOCTYPE html>
<head>
    <script src="./customer-service.js"></script>
</head>
<body>
    <!-- 打开客服按钮 -->
    <button onclick="openCS()">打开客服</button>
    <script>
        function openCS() {
            CustomerService.open(
                'player001',                              // 玩家UID
                '1',                                      // 区服ID
                'http://localhost:3001/api/get-cs-auth' // 游戏服务器签名接口
            );
        }
    </script>
</body>
```
---

### 4.4 微信小程序

