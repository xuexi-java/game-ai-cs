## 1. 整体接入流程
```text
玩家
  │
  │ 0. 点击 客服中心
  ▼
游戏客户端
  │
  │ 1. 向游戏服请求客服URL
  ▼
游戏服务器
  │
  │ 2. 按规则拼接客服URL
  ▼
游戏客户端
  │
  │ 3. 根据客服URL,打开对应客服前端
  ▼
客服页面
```
## 2. 核心数据协议  
  
### 2.1 认证接口定义 (游戏客户端向游戏服务器)  
#### 请求参数  
| 字段名      | 类型     | 必填  | 说明        |     |
| :------- | :----- | :-- | :-------- | --- |
| `uid`    | String | 是   | 玩家唯一 ID   |     |
| `areaid` | String | 是   | 玩家所在区服 ID |     |
  
#### 成功响应示例
```json
{
  "success": true,
  "data": {
	  "gameid": "10001",
	  "uid": "player_001",
	  "areaid": "1",
	  "playerName": "测试玩家",
	  "ts": 1737003600000,
	  "nonce": "n7k9m2x4p6q8w3e5",
	  "sign": "981efc6fd37795c635fb038c6b466d6d",
	  "h5Url": "https://cs-web.yourgame.com"
	  }
}  
```  
  
---  
  
### 2.2 认证参数字段说明 (服务器端)
gameid 映射参考：  
- 新弹弹堂: "10001"  
- 弹弹堂大冒险: "10002"  
- 页游弹弹堂: "10003"  
  
| 参数名          | 类型     | 说明               |     |
| :----------- | :----- | :--------------- | --- |
| `gameid`     | String | 游戏标识             |     |
| `uid`        | String | 玩家唯一 ID          |     |
| `areaid`     | String | 玩家所在区服           |     |
| `playerName` | String | 玩家昵称             |     |
| `ts`         | Long   | 生成签名的时间戳 (毫秒)    |     |
| `nonce`      | String | 固定随机串            |     |
| `sign`       | String | 服务器计算好的签名        |     |
| `h5Url`      | String | 客服前端部署地址         |     |
| platform     | Sting  | 来自什么端(如:Android) |     |

  
---  
  
### 2.3 URL 拼接规则（游戏客户端）  
当前采用 URL 传参模式，游戏客户端需要拼接完整 URL 并打开 WebView。  
**最终 URL 拼接示例**：  
`{h5Url}[/]?gameid={gameid}&uid={uid}&areaid={areaid}&ts={ts}&nonce={nonce}&sign={sign}&playerName={PlayerName}&platform=android 
  
---  
  
## 3. 签名计算规则(服务器端)     
*   **算法**：`MD5`
*   **公式**：`sign = md5(gameid|uid|areaid|ts|nonce|secret).toLowerCase()`
*   **注意**：各参数用 `|` 分隔拼接  
计算示例

| 参数     | 值                                |
| ------ | -------------------------------- |
| gameid | 10001                            |
| uid    | player002                        |
| areaid | 1                                |
| ts     | 1737003600000                    |
| nonce  | n7k9m2x4p6q8w3e5                 |
| secret | s3cr3t_k7m9n2p4q6x8w1e5r0t2y4u6  |
| sign   | 8149c825a2f85d7a034cda231f10903d |

---  
  
## 4. 各平台接入示例与权限配置

### 4.1 Android 平台

#### 4.1.1 权限声明 (`AndroidManifest.xml`)
```xml
<!-- 网络权限 -->
<uses-permission android:name="android.permission.INTERNET" />
<!-- 相册权限 (Android 13+) -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
```

#### 4.1.2 接入代码 (Kotlin)
```kotlin
/**  
 * 表示签名参数 API 响应的数据类。  
 */  
data class SignedParamsResponse(val success: Boolean, val data: SignedParams?, val error: String?)  
  
/**  
 * 包含游戏/H5 身份验证和会话参数的数据类。  
 */  
data class SignedParams(  
    val h5Url: String,  
    val gameid: String,  
    val uid: String,  
    val areaid: String,  
    val playerName: String,  
    val ts: Long,  
    val nonce: String,   
    val sign: String  
)  
/**  
 * MainActivity 处理 Mock Player 应用程序的核心逻辑。  
 * 它从服务器获取验证参数，并在 WebView 中显示游戏/客服 H5 页面，同时提供 JavaScript Bridge 交互功能。  
 */  
class MainActivity : AppCompatActivity() {  
    private lateinit var webView: WebView  
    private lateinit var progressBar: ProgressBar  
    private var fileChooserCallback: ValueCallback<Array<Uri>>? = null  
    /**  
     * 存储当前玩家的签名参数，通过 JavaScript Bridge 与 H5 共享。  
     */  
    private var currentParams: SignedParams? = null  
    private val client = OkHttpClient()  
    private val gson = Gson()  
    /**  
     * 使用现代化的 Activity Result API 处理文件选择。  
     */  
    private val pickImageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->  
        val data = if (result.resultCode == RESULT_OK) result.data?.data?.let { arrayOf(it) } else null  
        fileChooserCallback?.onReceiveValue(data)  
        fileChooserCallback = null  
    }  
    companion object {  
        private const val TAG = "MockPlayer"  
    }  
    /**  
     * 获取客服身份验证参数的接口地址。  
     * 注意：10.0.2.2 是从 Android 模拟器访问宿主机 localhost 的默认 IP。  
     */  
    private val GAME_SERVER_URL = "http://10.0.2.2:3001/api/get-cs-auth"  
  
    override fun onCreate(savedInstanceState: Bundle?) {  
        super.onCreate(savedInstanceState)  
        supportActionBar?.hide()  
        setContentView(R.layout.activity_main)  
        webView = findViewById(R.id.webView)  
        progressBar = findViewById(R.id.progressBar)  
        // 处理沉浸式状态栏及系统栏间距  
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->  
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())  
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)  
            insets  
        }  
        setupWebView()  
        // 示例：启动时请求特定玩家的签名参数  
        requestSignedParams("player001", "1")  
    }  
    /**  
     * 获取用户的签名参数，然后加载 H5 页面。  
     * @param uid 用户唯一 ID。  
     * @param areaid 区服 ID。  
     */  
    private fun requestSignedParams(uid: String, areaid: String) {  
        progressBar.visibility = View.VISIBLE  
        lifecycleScope.launch {  
            try {  
                val result = fetchAuthFromServer(uid, areaid)  
                if (result != null && result.success && result.data != null) {  
                    currentParams = result.data  
                    loadCustomerServiceUrl(result.data)  
                } else {  
                    val msg = result?.error ?: "数据解析失败"  
                    showError("获取签名失败: $msg")  
                }  
            } catch (e: Exception) {  
                showError("网络请求异常: ${e.message}")  
            }  
        }  
    }  
    /**  
     * 从后端服务器获取验证数据的网络请求。  
     */  
    private suspend fun fetchAuthFromServer(uid: String, areaid: String): SignedParamsResponse? = withContext(Dispatchers.IO) {  
        val json = gson.toJson(mapOf("uid" to uid, "areaid" to areaid))  
        val body = json.toRequestBody("application/json".toMediaType())  
        val request = Request.Builder().url(GAME_SERVER_URL).post(body).build()  
        try {  
            client.newCall(request).execute().use { response ->  
                val bodyStr = response.body?.string()  
                Log.d(TAG, "Server Response: $bodyStr")  
                if (!response.isSuccessful) return@withContext null  
                gson.fromJson(bodyStr, SignedParamsResponse::class.java)  
            }  
        } catch (e: Exception) {  
            Log.e(TAG, "Fetch Error", e)  
            null  
        }  
    }  
    /**  
     * 初始化 WebView 设置，配置 JavaScript 接口，并处理 ChromeClient/WebViewClient 事件。  
     */  
    @SuppressLint("SetJavaScriptEnabled")  
    private fun setupWebView() {  
        webView.settings.apply {  
            javaScriptEnabled = true  
            domStorageEnabled = true  
            allowFileAccess = true  
            mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW  
        }  
        // 将 Bridge 以 'AndroidBridge' 的名称暴露给 JavaScript        webView.addJavascriptInterface(object {  
            @JavascriptInterface  
            fun close() = runOnUiThread { finish() }  
            /**  
             * 向 H5 环境提供当前玩家信息。  
             */  
            @JavascriptInterface  
            fun getPlayerInfo(): String {  
                val json = currentParams?.let { gson.toJson(it) } ?: "{}"  
                Log.d(TAG, "JS Bridge 调用 getPlayerInfo: $json")  
                return json  
            }  
        }, "AndroidBridge")  
        webView.webChromeClient = object : WebChromeClient() {  
            /**  
             * 处理 WebView 发起的选择文件请求（例如在客服聊天中上传图片）。  
             */  
            override fun onShowFileChooser(webView: WebView?, callback: ValueCallback<Array<Uri>>?, params: FileChooserParams?): Boolean {  
                fileChooserCallback?.onReceiveValue(null)  
                fileChooserCallback = callback  
                val intent = Intent(Intent.ACTION_PICK).apply { type = "image/*" }  
                pickImageLauncher.launch(intent)  
                return true  
            }  
        }  
        webView.webViewClient = object : WebViewClient() {  
            override fun onPageFinished(view: WebView?, url: String?) {  
                progressBar.visibility = View.GONE  
            }  
            override fun onReceivedError(view: WebView?, request: WebResourceRequest?, error: WebResourceError?) {  
                super.onReceivedError(view, request, error)  
                runOnUiThread {  
                    Toast.makeText(this@MainActivity, "加载失败: ${error?.description}", Toast.LENGTH_LONG).show()  
                }  
            }  
        }  
    }  
    /**  
     * 使用 Uri.Builder 构造最终 URL，自动处理参数拼接逻辑和编码，避免双问号等 Bug。  
     */  
    private fun loadCustomerServiceUrl(params: SignedParams) {  
        val baseUri = Uri.parse(params.h5Url)  
        val builder = baseUri.buildUpon().apply {  
            // 如果基础路径没有参数且不以斜杠结尾，Uri.Builder 可能不会自动补斜杠，  
            // 但对于 Web 链接，通常 buildUpon() 会处理好路径与参数的分隔。  
            appendQueryParameter("gameid", params.gameid)  
            appendQueryParameter("uid", params.uid)  
            appendQueryParameter("areaid", params.areaid)  
            appendQueryParameter("ts", params.ts.toString())  
            appendQueryParameter("nonce", params.nonce)  
            appendQueryParameter("sign", params.sign)  
            appendQueryParameter("playerName", params.playerName)  
            appendQueryParameter("platform", "android")  
        }  
        val url = builder.build().toString()  
        Log.d(TAG, "Loading URL: $url")  
        webView.loadUrl(url)  
    }   
    override fun onDestroy() {  
        webView.destroy()  
        super.onDestroy()  
    }  
    /**  
     * 向用户显示错误消息并隐藏加载进度条。  
     */  
    private fun showError(msg: String) {  
        progressBar.visibility = View.GONE  
        Toast.makeText(this, msg, Toast.LENGTH_LONG).show()  
    }  
}
```
---
### 4.2 iOS 平台

#### 4.2.1 权限声明 (`Info.plist`)
```xml
<!-- 相册访问权限 -->
<key>NSPhotoLibraryUsageDescription</key>
<string>我们需要访问您的相册以提供截图上传功能</string>
```

#### 4.2.2 接入代码 (Swift)
```swift
敬请期待
```

#### 4.2.3 调用示例
```swift
敬请期待
```

---

### 4.3 Flash / 网页平台 (Iframe 嵌入)

#### 4.3.1 接入代码
```html
<!DOCTYPE html>  
<html>  
<head>  
    <title>客服中心</title>  
    <style>  
        /* 遮罩层样式 */  
        .cs-overlay {  
            position: fixed;  
            inset: 0;  
            display: none;  
            align-items: center;  
            justify-content: center;  
            background: rgba(2, 6, 23, 0.55);  
            z-index: 1000;  
        }  
        .cs-overlay.is-open {  
            display: flex;  
        }  
          
        /* 客服模态框容器 */  
        .cs-modal {  
            position: relative;  
            display: flex;  
            flex-direction: column;  
            width: min(820px, calc(100% - 48px));  
            height: min(600px, calc(100% - 48px));  
            border-radius: 8px;  
            overflow: hidden;  
            background: #020617;  
            border: 1px solid #1f2937;  
            box-shadow: 0 24px 64px rgba(0, 0, 0, 0.45);  
        }  
          
        /* 客服头部 */  
        .cs-header {  
            padding: 8px 12px;  
            display: flex;  
            align-items: center;  
            justify-content: space-between;  
            gap: 8px;  
            background: #020617;  
            border-bottom: 1px solid #1f2937;  
            font-size: 13px;  
            color: #9ca3af;  
        }        
          
        /* iframe包装器 */  
        .cs-iframe-wrapper {  
            flex: 1;  
            background: #030712;  
        }  
          
        /* iframe样式 */  
        .cs-iframe {  
            width: 100%;  
            height: 100%;  
            border: none;  
            background: #030712;  
        }  
          
        /* 状态标签 */  
        .status-tag {  
            display: inline-flex;  
            align-items: center;  
            padding: 2px 6px;  
            border-radius: 999px;  
            border: 1px solid #4b5563;  
            font-size: 11px;  
            color: #9ca3af;  
            gap: 4px;  
        }  
          
        .tag-dot {  
            width: 6px;  
            height: 6px;  
            border-radius: 999px;  
            background: #22c55e;  
        }  
          
        .tag-dot.offline {  
            background: #6b7280;  
        }  
    </style>  
</head>  
<body>  
    <!-- 客服iframe容器 -->  
    <div class="cs-overlay" id="csOverlay" aria-hidden="true">  
        <div class="cs-modal" id="csModal">  
            <div class="cs-header">  
                <span>客服中心</span>  
                <span class="status-tag" id="statusTag">  
                    <span class="tag-dot offline" id="statusDot"></span>  
                    <span id="statusText">未加载</span>  
                </span>    
            </div>  
            <div class="cs-iframe-wrapper">  
                <iframe id="csFrame" class="cs-iframe"></iframe>  
            </div>  
        </div>  
    </div>  
  
    <script>  
    const CustomerService = {  
        // 获取DOM元素  
        elements: {  
            overlay: document.getElementById('csOverlay'),  
            frame: document.getElementById('csFrame'),  
            modal: document.getElementById('csModal'),  
            statusDot: document.getElementById('statusDot'),  
            statusText: document.getElementById('statusText'),    
        },  
  
        /**  
         * 初始化客服系统  
         */  
        init() {    
  
            // 监听H5通过postMessage发送的关闭消息  
            window.addEventListener('message', (e) => {  
                if (e && e.data && e.data.type === 'cs-close') {  
                    console.log('收到H5发送的cs-close消息，关闭客服');  
                    this.close();  
                }  
            });  
              
            // 初始状态设置  
            this.setStatus('未加载', false);  
        },  
  
        /**  
         * 设置客服窗口状态  
         * @param {string} label - 状态文本  
         * @param {boolean} online - 是否在线  
         */  
        setStatus(label, online) {  
            this.elements.statusText.textContent = label;  
            if (online) {  
                this.elements.statusDot.classList.remove('offline');  
            } else {  
                this.elements.statusDot.classList.add('offline');  
            }  
        },  
  
        /**  
         * 打开客服 (需先请求游戏服务器获取签名参数)  
         * @param {string} uid - 玩家ID  
         * @param {string} areaid - 区服ID  
         * @param {string} gameServerUrl - 游戏服务器获取签名接口地址  
         */  
        async open(uid, areaid, gameServerUrl) {  
            if (!uid) {  
                alert('UID不能为空');  
                return;  
            }  
  
            // 设置状态为获取签名中  
            this.setStatus('获取签名中...', false);  
  
            try {  
                // 1. 向游戏服务器请求签名参数  
                const res = await fetch(gameServerUrl, {  
                    method: 'POST',  
                    headers: { 'Content-Type': 'application/json' },  
                    body: JSON.stringify({ uid, areaid })  
                });  
  
                if (!res.ok) {  
                    throw new Error('HTTP ' + res.status);  
                }  
  
                const json = await res.json();  
                if (!json.success) {  
                    throw new Error(json.error || '获取签名失败');  
                }  
  
                const data = json.data || {};  
                  
                // 验证必要参数是否存在  
                const h5Url = data.h5Url || data.csH5Url || '';  
                if (!h5Url) {  
                    throw new Error('返回数据中缺少h5Url');  
                }  
  
                // 2. 构建URL参数  
                const params = {  
                    gameid: data.gameid,  
                    uid: data.uid,  
                    areaid: data.areaid,  
                    ts: String(data.ts || ''),  
                    nonce: data.nonce,  
                    sign: data.sign,  
                    playerName: data.playerName || '',  
                    platform: 'iframe'  // 标识来自iframe嵌入  
                };  
  
                console.log('获取签名成功:', data);  
                this.setStatus('加载H5中...', false);  
                  
                // 3. 拼接URL并打开客服  
                this.openCustomerServiceWithUrl(h5Url, params);  
            } catch (err) {  
                console.error(err);  
                alert('获取签名失败：' + err.message);  
                this.setStatus('获取签名失败', false);  
            } 
        },  
  
        /**  
         * 使用指定URL和参数打开客服  
         * @param {string} h5Url - 客服H5页面基础URL  
         * @param {Object} params - URL参数对象  
         */  
        openCustomerServiceWithUrl(h5Url, params) {  
            const search = new URLSearchParams(params).toString();  
            this.elements.frame.src = `${h5Url.replace(/\/+$/, '')}/?${search}`;  
            this.elements.overlay.classList.add('is-open');  
            this.elements.overlay.setAttribute('aria-hidden', 'false');  
            this.setStatus('已加载', true);  
            console.log('打开客服：', this.elements.frame.src);  
        },  
  
        /**  
         * 关闭客服窗口  
         */  
        close() {  
            this.elements.frame.src = 'about:blank';  
            this.elements.overlay.classList.remove('is-open');  
            this.elements.overlay.setAttribute('aria-hidden', 'true');  
            this.setStatus('已关闭', false);  
            console.log('关闭客服Iframe');  
        }  
    };  
  
    // 初始化客服系统  
    CustomerService.init();  
      
    // 示例：页面加载完成后可以绑定触发函数  
    // document.getElementById('btnCS').onclick = () => {  
    //     CustomerService.open('player_001', '1', 'https://your-game-server.com/api/get-cs-auth');  
    // };  
    </script>  
</body>  
</html>
```
---

### 4.4 微信小程序

#### 4.4.1 域名配置
在微信公众平台 → 开发管理 → 业务域名中添加客服前端域名。

#### 4.4.2 接入代码

**WXML**
```html
敬请期待
```

**JS**
```javascript
敬请期待
```

#### 4.4.3 调用示例
```javascript
敬请期待
```
