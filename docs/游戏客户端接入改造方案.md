# 游戏客户端接入改造方案

## 一、改造概述

### 1.1 背景

当前系统玩家端采用独立网页形式，需要改造为游戏内嵌入式 WebView，简化接口设计，实现极简接入。

### 1.2 改造目标

| 项目 | 当前状态 | 目标状态 |
|------|---------|---------|
| 玩家端形态 | 独立网页应用 | 游戏内嵌入 WebView |
| HTTP 接口 | 10+ 个接口 | **1 个 Bootstrap 接口** |
| 图片上传 | 未实现 | 独立上传接口 |
| 后续交互 | HTTP 请求 | **全部走 WebSocket** |
| 认证方式 | Token 自动生成 | 签名验证 (MD5 + ts + nonce) |

### 1.3 核心设计理念

```
极简接入：
1. 只有 1 个 HTTP 接口 (/api/player/connect) 作为 Bootstrap 总入口
2. 所有后续操作通过 WebSocket 完成
3. 图片上传单独 1 个接口 (/api/player/upload)
```

### 1.4 关键安全原则

| 原则 | 说明 |
|------|------|
| **密钥不下发** | secret 只存在于游戏服务器，绝不下发到游戏客户端 |
| **签名防重放** | 签名包含 ts + nonce，服务端校验时效和去重 |
| **WS Token验证** | WebSocket 连接使用一次性 token，由 connect 接口返回 |

---

## 二、系统架构

### 2.1 架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Unity 游戏客户端 (APK)                          │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                 WebView (webview-player)                       │  │
│  │  ┌─────────────────────────────────────────────────────────┐  │  │
│  │  │  Vue3 网页应用                                           │  │  │
│  │  │  • 直接调用客服服务器 HTTP 接口                          │  │  │
│  │  │  • 直接连接客服服务器 WebSocket                          │  │  │
│  │  │  • 直接上传图片到客服服务器                              │  │  │
│  │  └─────────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                              ↕ JS Bridge                            │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                     Unity C# Bridge                            │  │
│  │  • getPlayerInfo() → 返回玩家信息                              │  │
│  │  • getSignedParams() → 调用游戏服务器获取签名参数              │  │
│  │  • close() → 关闭 WebView                                     │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
          │                                        │
          │ HTTP (获取签名参数)                     │ HTTP/WebSocket (直连)
          ▼                                        ▼
┌──────────────────────┐                ┌──────────────────────────────┐
│    游戏服务器         │                │      客服服务器 (云)          │
│  ┌────────────────┐  │                │  ┌────────────────────────┐  │
│  │ • 持有 secret   │  │                │  │ POST /api/player/connect│  │
│  │ • 计算签名      │  │                │  │ POST /api/player/upload │  │
│  │ • 返回签名参数  │  │                │  │ WebSocket /socket.io    │  │
│  └────────────────┘  │                │  └────────────────────────┘  │
└──────────────────────┘                │  ┌──────────────┐  ┌──────┐  │
                                        │  │  PostgreSQL  │  │Redis │  │
                                        │  │  工单/消息    │  │缓存  │  │
                                        │  └──────────────┘  └──────┘  │
                                        └──────────────────────────────┘
```

### 2.2 数据流向

```
【初始化流程】

1. 玩家点击"客服"按钮
   └─► Unity 打开 WebView，加载 webview-player 网页

2. WebView 初始化
   └─► 调用 Bridge.getPlayerInfo() 获取玩家信息
   └─► 调用 Bridge.getSignedParams() 获取签名参数
       └─► Unity 调用游戏服务器
       └─► 游戏服务器计算签名: sign = md5(gameid|uid|areaid|ts|nonce|secret)
       └─► 返回签名参数给 WebView

3. 调用 Bootstrap 接口
   └─► WebView 直接调用 POST /api/player/connect
   └─► 客服服务器验证签名，返回:
       • wsUrl: WebSocket 连接地址
       • questList: 问题分类列表
       • agentAvailable: 客服是否在线
       • activeTicket: 未完成的工单（如有）

4. 根据返回决定流程
   ├─► 有旧工单 → 显示"继续咨询/新问题"选择弹窗
   └─► 无旧工单 → 显示问题分类菜单

5. 建立 WebSocket 连接
   └─► 连接 wsUrl
   ├─► 新工单: emit('ticket:create', {issueType})
   └─► 恢复工单: emit('ticket:resume', {tid})

6. 聊天交互（全部通过 WebSocket）
   ├─► 发消息: emit('message:send', {...})
   ├─► 收消息: on('message:receive', ...)
   ├─► 转人工: emit('transfer:request')
   └─► 关闭工单: emit('ticket:close')

7. 图片上传（单独 HTTP 接口）
   └─► POST /api/player/upload (用 tid+key 验证)
```

---

## 三、核心业务规则

### 3.1 工单数量约束

| 规则 | 说明 |
|------|------|
| **强约束** | 同一 (gameid, uid, areaid) 最多只能有 **1个** 未关闭工单 |
| **异常处理** | 如果历史数据/异常导致出现多个开放工单，取最新的作为 activeTicket，其他自动关闭并记录 reason=DATA_CLEANUP |

### 3.2 新建工单流程

```
1. 玩家选择问题分类
   ↓
2. 如有旧工单 → 弹确认框："您有未完成的工单，新建将关闭旧工单，是否继续？"
   ↓
3. 用户确认 → emit('ticket:create', { issueType, confirmClose: true })
   ↓
4. 服务端处理顺序（关键）：
   a) 先创建新工单
   b) 新工单创建成功后，才关闭旧工单
   c) 关闭原因记录为 AUTO_CLOSED_BY_NEW_TICKET
   ↓
5. 旧工单一旦被自动关闭，**不可恢复**（避免反复横跳）
```

**异常处理：创建新单成功但关闭旧单失败**
```
场景：新工单创建成功，但关闭旧工单时 DB 失败
处理策略：
1. 新工单已创建 → 正常返回给玩家，不影响使用
2. 旧工单标记 closePending = true（新增字段）
3. 异步补偿任务（每 5 分钟）扫描 closePending=true 的工单，执行关闭
4. 补偿成功 → closePending = false, status = RESOLVED
5. 同一玩家下次 connect 时，如检测到 closePending 工单，强制关闭

这样避免出现"两个 OPEN 工单"的数据异常
```

### 3.3 恢复工单 (resume)

| 项目 | 规则 |
|------|------|
| **可恢复状态** | 仅 WAITING / IN_PROGRESS 状态可恢复 |
| **已关闭工单** | RESOLVED 状态 → **只读模式**，可查看历史，不可发消息 |
| **历史消息** | 恢复时自动返回最近 50 条消息 |
| **排序规则** | 按时间升序返回（旧消息在前） |

**已关闭工单只读模式**
```javascript
// 尝试恢复已关闭工单
socket.emit('ticket:resume', { tid: 'T-xxx' });

// 服务器返回只读模式
socket.on('ticket:resumed', {
  tid: 'T-xxx',
  status: 'RESOLVED',
  readOnly: true,  // 只读标记
  history: [...],
  closeReason: 'RESOLVED',
  closedAt: '2024-12-15T18:00:00Z'
});

// 客户端检测到 readOnly=true → 禁用输入框，显示"工单已关闭"
```

### 3.4 工单描述收集

| 项目 | 规则 |
|------|------|
| **创建时** | 工单 description 字段为空 |
| **首条消息** | 玩家发送的第一条消息自动更新为工单描述（截取前500字符） |
| **客服端显示** | 显示此描述作为问题摘要 |

### 3.5 AI 与人工路由规则

```
【路由优先级】
1. issueType.routeMode = 'HUMAN' → 跳过 AI 首答，直接排队人工
2. issueType.routeMode = 'AI' (默认) → AI 首答，玩家可手动转人工

【转人工幂等性】
• 已在排队 → 返回当前排队位置，不重复入队
• 已有客服接入 → 返回当前客服信息
• 重复调用 transfer:request → 幂等处理，返回当前状态
```

### 3.6 排队与服务不可用

| 场景 | 处理方式 |
|------|---------|
| 正常排队 | 返回 `transfer:result { success: true, queuePosition, waitTime }` |
| 排队位置变化 | 推送 `queue:update { queuePosition, waitTime }` |
| 无客服在线 | 返回 `transfer:result { success: false, reason: 'NO_AGENT_ONLINE' }` |
| 非工作时间 | 返回 `transfer:result { success: false, reason: 'OFF_HOURS' }` |
| 断线重连 | **保留排队位置**，重连后继续等待 |

### 3.7 WebSocket 连接规则

| 规则 | 说明 |
|------|------|
| **连接策略** | 同一 (gameid, uid, areaid) 只允许 **1个** WebSocket 连接 |
| **踢人机制** | 新连接建立时，踢掉旧连接，旧端收到 `connection:kicked { reason: 'NEW_CONNECTION' }` |
| **踢人时机** | 新连接验证通过后再踢旧连接，避免新连接失败导致两边都断 |

### 3.8 Token 生命周期

| 项目 | 规则 |
|------|------|
| **有效期** | 1小时 |
| **可重连** | 有效期内允许多次重连（断线重连场景） |
| **过期处理** | token 过期但工单仍 OPEN → 玩家需重新调用 connect 获取新 token |

### 3.9 消息幂等规则

| 项目 | 规则 |
|------|------|
| **客户端要求** | 每条消息携带 `clientMsgId` (UUID) |
| **服务端去重** | 5分钟窗口内，同 tid + clientMsgId 视为同一条消息 |
| **重复消息处理** | 返回已存在的消息，不重复入库 |

---

## 四、接口设计

### 4.1 Bootstrap 总入口：`/api/player/connect`

**功能**：一次性返回所有初始化需要的信息

**请求**
```
POST /api/player/connect
Content-Type: application/json
```

**请求参数**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| gameid | string | 是 | 游戏ID |
| uid | string | 是 | 玩家UID |
| areaid | string | 是 | 区服号 |
| playerName | string | 否 | 玩家昵称 |
| ts | number | 是 | 时间戳(毫秒) |
| nonce | string | 是 | 随机串(16-32位) |
| sign | string | 是 | 签名 |

**请求示例**
```json
{
  "gameid": "game001",
  "uid": "player123",
  "areaid": "server01",
  "playerName": "张三",
  "ts": 1734264000000,
  "nonce": "a1b2c3d4e5f6g7h8",
  "sign": "a1b2c3d4e5f6g7h8i9j0..."
}
```

**响应 - 成功（有未完成工单）**
```json
{
  "result": true,
  "data": {
    "wsUrl": "wss://cs.example.com/socket.io",
    "wsToken": "abc123xyz",
    "uploadToken": "upload_abc123xyz",
    "questList": [
      { "id": "issue-001", "name": "账号问题", "icon": "account", "routeMode": "AI" },
      { "id": "issue-002", "name": "充值问题", "icon": "payment", "routeMode": "HUMAN" },
      { "id": "issue-003", "name": "游戏Bug", "icon": "bug", "routeMode": "AI" }
    ],
    "agentAvailable": true,
    "workingHours": "09:00-18:00",
    "activeTicket": {
      "tid": "T-20241215-12345678",
      "status": "IN_PROGRESS",
      "description": "账号被盗问题",
      "createdAt": "2024-12-15T10:30:00Z",
      "issueType": "账号问题",
      "isAgentConnected": true
    },
    "history": [
      {
        "id": "msg-001",
        "content": "我的账号被盗了",
        "senderType": "PLAYER",
        "messageType": "TEXT",
        "createdAt": "2024-12-15T10:30:00Z"
      },
      {
        "id": "msg-002",
        "content": "您好，账号安全问题我来帮您处理...",
        "senderType": "AI",
        "messageType": "TEXT",
        "createdAt": "2024-12-15T10:30:05Z"
      }
    ],
    "bootstrapMessages": []
  }
}
```

**响应 - 无未完成工单（首次进入）**
```json
{
  "result": true,
  "data": {
    "wsUrl": "wss://cs.example.com/socket.io",
    "wsToken": "abc123xyz",
    "uploadToken": "upload_abc123xyz",
    "questList": [...],
    "agentAvailable": true,
    "workingHours": "09:00-18:00",
    "activeTicket": null,
    "history": [],
    "bootstrapMessages": [
      {
        "id": "bootstrap-001",
        "content": "您好！我是AI助手，请问有什么可以帮助您的？",
        "senderType": "SYSTEM",
        "messageType": "TEXT"
      }
    ]
  }
}
```

**响应 - 失败**
```json
{
  "result": false,
  "error": "签名验证失败",
  "errorCode": "INVALID_SIGN"
}
```

**questList 与 bootstrapMessages 的职责分工**
```
questList（问题分类列表）:
  - 用途：前端绘制"问题分类"选择 UI
  - 内容：id, name, icon, routeMode
  - 前端处理：渲染为可点击的分类按钮/卡片

bootstrapMessages（首屏消息）:
  - 用途：首屏消息区需要显示的内容
  - 首次进入（无旧工单）：显示欢迎语，如"您好！我是AI助手..."
  - 有旧工单：为空（history 已包含历史消息）

推荐做法：
1. 前端优先渲染 bootstrapMessages（如果非空）
2. 然后基于 questList 渲染分类选择 UI（独立组件，不在消息流里）
3. 这样前端逻辑最清晰，欢迎语和菜单分离
```

---

### 4.2 图片上传：`/api/player/upload`

**请求**
```
POST /api/player/upload
Headers:
  X-Upload-Token: {uploadToken}
Content-Type: multipart/form-data
```

**鉴权说明**

| 字段 | 来源 | 说明 |
|------|------|------|
| X-Upload-Token | `/api/player/connect` 返回的 `uploadToken` | 专用于图片上传，与 wsToken 分离 |

**uploadToken 设计**
```
生成规则: uploadToken = sign(gameid|uid|areaid|tid|expireAt, secret)
有效期: 10 分钟（比 wsToken 短，减少泄漏风险）
权限范围: 仅允许上传图片，不能建立 WebSocket 连接
后端校验: 解析 token → 验证 (gameid, uid, areaid) → 验证 tid 归属 → 允许上传
```

**请求参数**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| file | File | 是 | 图片文件 |

**响应 - 成功**
```json
{
  "result": true,
  "data": {
    "url": "https://cs.example.com/uploads/2024/12/15/abc123.jpg",
    "filename": "abc123.jpg",
    "size": 102400
  }
}
```

**图片限制**

| 项目 | 限制 |
|------|------|
| 最大文件大小 | 5MB |
| 支持格式 | jpg, jpeg, png, gif, webp, heic, heif |
| 建议压缩 | 前端压缩到 maxWidth=1920, quality=0.8 |
| HEIC 处理 | 后端统一转码为 JPEG（iOS 常用格式） |

---

## 五、WebSocket 协议

### 5.1 连接方式

```
使用 /api/player/connect 返回的 wsUrl + wsToken 连接
Token 通过 Socket.IO auth 字段传递（避免 URL 日志泄漏）
```

**前端连接示例**
```typescript
import { io } from 'socket.io-client';

const socket = io(wsUrl, {
  auth: {
    token: wsToken  // connect 返回的 wsToken
  },
  transports: ['websocket'],
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000
});
```

**后端验证**
```typescript
// 在 handleConnection 或中间件中
const token = client.handshake.auth?.token;
if (!token) {
  throw new WsException('INVALID_TOKEN');
}
```

### 5.1.1 Socket-Ticket 绑定规则

**核心原则**：Socket 连接后必须先 `ticket:create` 或 `ticket:resume`，服务端将该 socket 绑定到当前 tid。

```
【绑定流程】
1. 客户端连接成功 → 收到 connection:ready
2. 客户端必须调用 ticket:create 或 ticket:resume
3. 服务端成功后，将 (socketId → tid) 绑定关系存入内存/Redis
4. 后续 message:send / transfer:request / typing:update / ticket:close
   均默认作用于已绑定的 tid（无需显式传 tid）

【硬规则】
- 未绑定 tid 的 socket 调用 message:send → 返回 error { code: 'NO_TICKET_BOUND' }
- 绑定后再调用 ticket:create/resume → 覆盖旧绑定（允许在同一连接切换工单）
- 断线重连后需重新绑定（调用 ticket:resume）
```

### 5.1.2 客户端可发消息时机

**输入框解锁条件**：只有在收到 `ticket:created` 或 `ticket:resumed` 且 `readOnly != true` 后，输入框才解锁为可发送。

```typescript
// 前端状态机示例
type InputState = 'DISABLED' | 'ENABLED' | 'READ_ONLY';

socket.on('ticket:created', () => {
  inputState = 'ENABLED';  // 新工单，可发消息
});

socket.on('ticket:resumed', (data) => {
  inputState = data.readOnly ? 'READ_ONLY' : 'ENABLED';
});

// 发送前检查
function canSend(): boolean {
  return inputState === 'ENABLED';
}
```

### 5.2 客户端 → 服务器 事件

| 事件 | 参数 | 说明 |
|------|------|------|
| `ticket:create` | `{issueType, confirmClose?}` | 创建新工单 |
| `ticket:resume` | `{tid}` | 恢复旧工单 |
| `message:send` | `{content, clientMsgId, type?}` | 发送消息 |
| `transfer:request` | `{}` | 请求转人工客服 |
| `ticket:close` | `{reason?}` | 玩家主动关闭工单 |
| `history:load` | `{beforeId?, limit?}` | 加载更多历史消息 |
| `typing:update` | `{isTyping}` | 输入状态变化 |

### 5.3 服务器 → 客户端 事件

| 事件 | 参数 | 说明 |
|------|------|------|
| `connection:ready` | `{status}` | 连接就绪 |
| `ticket:created` | `{tid, status}` | 工单创建成功 |
| `ticket:resumed` | `{tid, status, history, readOnly?}` | 工单恢复成功，含历史消息（RESOLVED 时 readOnly=true） |
| `message:ack` | `{clientMsgId, messageId, createdAt}` | **消息发送确认（必须）** |
| `message:receive` | `{id, content, senderType, messageType, createdAt, suggestions?}` | 收到新消息 |
| `transfer:result` | `{success, queuePosition?, waitTime?, reason?, message?}` | 转人工结果 |
| `queue:update` | `{queuePosition, waitTime}` | 排队位置更新 |
| `agent:assigned` | `{agentId, agentName}` | 客服已接入 |
| `ticket:update` | `{status, closeReason?}` | 工单状态变更 |
| `typing:status` | `{senderType, isTyping}` | 对方输入状态 |
| `connection:kicked` | `{reason}` | 被踢下线 |
| `history:loaded` | `{messages[], hasMore}` | 历史消息加载完成 |
| `error` | `{code, message}` | 错误信息 |

### 5.4 事件详细说明

#### ticket:create 事件
```javascript
// 客户端发送
socket.emit('ticket:create', {
  issueType: 'issue-001',
  confirmClose: true  // 如果有旧工单需要关闭
});

// 服务器响应
socket.on('ticket:created', {
  tid: 'T-20241215-12345678',
  status: 'IN_PROGRESS'
});
```

#### message:send 事件
```javascript
// 客户端发送
socket.emit('message:send', {
  content: '我的账号被盗了，怎么办？',
  clientMsgId: 'msg_1734264000000_abc123',
  type: 'TEXT'  // TEXT | IMAGE
});

// 服务器确认收到（必须等待此 ACK 才能标记发送成功）
socket.on('message:ack', {
  clientMsgId: 'msg_1734264000000_abc123',
  messageId: 'msg-xxx',           // 服务端生成的消息ID
  createdAt: '2024-12-15T10:30:00Z'
});

// 服务器推送消息（包含 AI 回复）
socket.on('message:receive', {
  id: 'msg-xxx',
  content: '您好，账号安全问题我来帮您处理...',
  senderType: 'AI',  // PLAYER | AI | AGENT | SYSTEM
  messageType: 'TEXT',
  createdAt: '2024-12-15T10:30:05Z',
  suggestions: ['找回密码', '申诉', '转人工']
});
```

#### message:ack 幂等规则
```
1. 服务端收到 message:send 后，先查 Redis 去重 (tid + clientMsgId)
2. 如果是新消息：入库 → 回 ack { clientMsgId, messageId, createdAt }
3. 如果是重复消息：直接返回已有的 ack（同一个 messageId）
4. 客户端收到 ack 后，将消息状态从 "sending" 改为 "sent"
5. 超时未收到 ack → 客户端可重发（相同 clientMsgId），服务端幂等处理
```

#### IMAGE 消息入库结构
```
【发送流程】
1. 玩家选图 → 前端调用 /api/player/upload → 获取 url
2. 前端 emit('message:send', { content: url, type: 'IMAGE', clientMsgId })
3. 服务端入库：messageType='IMAGE', content=url

【数据库存储】
Message 表:
  messageType: 'IMAGE'
  content: 'https://cs.example.com/uploads/xxx.jpg'  // 只存 URL

【客服端渲染】
- 支持图片：根据 messageType='IMAGE'，将 content 渲染为 <img>
- 不支持图片（MVP 降级）：将 content 渲染为可点击链接

【图片消息示例】
// 玩家发送图片
{
  "id": "msg-123",
  "senderType": "PLAYER",
  "messageType": "IMAGE",
  "content": "https://cs.example.com/uploads/2024/12/15/abc.jpg",
  "createdAt": "2024-12-15T10:35:00Z"
}

// 客服端降级渲染（如暂不支持图片预览）
<a href="{content}" target="_blank">[图片]</a>
```

#### transfer:request 事件
```javascript
// 客户端发送
socket.emit('transfer:request');

// 服务器响应 - 成功
socket.on('transfer:result', {
  success: true,
  queuePosition: 3,
  waitTime: 180
});

// 服务器响应 - 失败（无客服在线）
socket.on('transfer:result', {
  success: false,
  reason: 'NO_AGENT_ONLINE',
  message: '当前无客服在线，您可以继续与 AI 对话或保存工单稍后咨询'
});

// 排队位置更新
socket.on('queue:update', {
  queuePosition: 2,
  waitTime: 120
});

// 客服接入
socket.on('agent:assigned', {
  agentId: 'agent-001',
  agentName: '客服小王'
});
```

#### history:load 事件（加载更多历史）
```javascript
// 客户端发送（向上滚动加载更早的消息）
socket.emit('history:load', {
  beforeId: 'msg-050',  // 加载该消息之前的更早消息（不包含此条）
  limit: 30             // 每次加载条数，默认 30，最大 100
});

// 服务器响应
socket.on('history:loaded', {
  messages: [
    { id: 'msg-020', content: '...', createdAt: '2024-12-15T09:00:00Z' },
    { id: 'msg-021', content: '...', createdAt: '2024-12-15T09:01:00Z' },
    // ... 按时间升序排列（旧→新）
    { id: 'msg-049', content: '...', createdAt: '2024-12-15T10:29:00Z' }
  ],
  hasMore: true  // 还有更早的消息
});
```

**history:load 规则说明**
```
1. messages 按时间升序返回（旧消息在前，新消息在后）
2. beforeId 含义：加载 id 对应消息之前的更早消息（不包含该 id）
3. 首次加载（beforeId 为空）：返回最新的 N 条消息
4. 滚动加载：用当前最早消息的 id 作为 beforeId
5. hasMore = false 时，表示已加载到最早的消息
```

---

## 六、签名算法

### 6.1 签名生成（游戏服务器端）

```
签名公式: sign = md5(gameid|uid|areaid|ts|nonce|secret).toLowerCase()

示例:
- gameid: "game001"
- uid: "player123"
- areaid: "server01"
- ts: 1734264000000
- nonce: "a1b2c3d4e5f6g7h8"
- secret: "your_secret_key"

拼接字符串: "game001|player123|server01|1734264000000|a1b2c3d4e5f6g7h8|your_secret_key"
MD5后: "a1b2c3d4..."
```

### 6.2 签名验证规则

| 验证项 | 规则 | 错误码 |
|--------|------|--------|
| 时间戳 | ts 与服务器时间差不超过 5 分钟 | EXPIRED_REQUEST |
| Nonce | 5分钟内同一 (gameid, areaid, uid, nonce) 不能重复 | DUPLICATE_NONCE |
| 签名值 | MD5 计算结果匹配 | INVALID_SIGN |

---

## 七、Bridge 接口设计

### 7.1 接口定义

| 方法 | 输入 | 输出 | 说明 |
|------|------|------|------|
| `getPlayerInfo` | - | `{gameid, uid, areaid, playerName}` | 获取玩家基本信息 |
| `getSignedParams` | `{endpoint, body}` | `{gameid, uid, areaid, ts, nonce, sign, ...body}` | 获取签名后的请求参数 |
| `close` | - | - | 关闭 WebView |

### 7.2 Unity 实现示例

```csharp
public class CSBridge : MonoBehaviour
{
    private UniWebView webView;
    private string gameid = "game001";
    private string uid;
    private string areaid;
    private string playerName;

    // 1. 获取玩家信息
    public string CSBridge_GetPlayerInfo()
    {
        return JsonUtility.ToJson(new {
            gameid = this.gameid,
            uid = this.uid,
            areaid = this.areaid,
            playerName = this.playerName
        });
    }

    // 2. 获取签名参数（调用游戏服务器）
    public async void CSBridge_GetSignedParams(string paramsJson, string callbackId)
    {
        var request = JsonUtility.FromJson<SignRequest>(paramsJson);

        // 调用游戏服务器获取签名
        var signedParams = await GameServer.GetSignedParams(
            gameid, uid, areaid, request.endpoint, request.body
        );

        // 返回给 WebView
        string result = JsonUtility.ToJson(signedParams);
        webView.EvaluateJavaScript($"window.CSBridge_Callback('{callbackId}', {result})");
    }

    // 3. 关闭 WebView
    public void CSBridge_Close()
    {
        webView.Hide();
        Destroy(webView);
    }
}
```

### 7.3 WebView 端调用示例

```typescript
// services/bridge.ts
export async function getPlayerInfo(): Promise<PlayerInfo> {
  if (window.Unity) {
    return JSON.parse(window.Unity.call('getPlayerInfo'));
  }
  // Web 环境降级
  return { gameid: 'test', uid: 'test-user', areaid: 'test-area', playerName: 'Test' };
}

export async function getSignedParams(endpoint: string, body: object): Promise<SignedParams> {
  return new Promise((resolve) => {
    const callbackId = `cb_${Date.now()}`;
    window.CSBridge_Callback = (id: string, result: string) => {
      if (id === callbackId) {
        resolve(JSON.parse(result));
      }
    };
    window.Unity.call('getSignedParams', JSON.stringify({ endpoint, body }), callbackId);
  });
}

export function close(): void {
  if (window.Unity) {
    window.Unity.call('close');
  }
}
```

---

## 八、数据库设计

### 8.1 Game 表新增字段

```prisma
model Game {
  // 现有字段...

  playerApiSecret   String?   @db.VarChar(64)   // 玩家接口签名密钥
  playerApiEnabled  Boolean   @default(true)    // 是否启用玩家API
}
```

### 8.2 Ticket 表新增字段

```prisma
model Ticket {
  // 现有字段...

  playerUid        String?    @db.VarChar(64)   // 玩家UID
  playerAreaId     String?    @db.VarChar(64)   // 玩家区服号
  closeReason      String?    @db.VarChar(64)   // 关闭原因
  closedBy         String?    @db.VarChar(32)   // 关闭者: PLAYER/AGENT/SYSTEM
  lastMessageAt    DateTime?                     // 最后消息时间

  @@index([gameId, playerUid, playerAreaId, status])
  @@index([status, lastMessageAt])
}
```

### 8.3 IssueType 表新增字段

```prisma
model IssueType {
  // 现有字段...

  routeMode  String  @default("AI")  // 路由模式: AI / HUMAN
}
```

---

## 九、Redis 存储设计

### 9.1 WebSocket Token

```
Key:    player:ws:token:{token}
Value:  {"gameid", "uid", "areaid", "playerName", "createdAt"}
TTL:    3600秒 (1小时)
```

### 9.2 Nonce 去重

```
Key:    player:nonce:{gameid}:{areaid}:{uid}:{nonce}
Value:  "1"
TTL:    300秒 (5分钟)
```

### 9.3 玩家连接状态

```
Key:    player:socket:{gameid}:{areaid}:{uid}
Value:  {"socketId", "tid", "connectedAt"}
TTL:    86400秒 (24小时)
用途:   用于踢掉旧连接
```

### 9.4 消息去重

```
Key:    player:msg:{tid}:{clientMsgId}
Value:  messageId
TTL:    300秒 (5分钟)
```

---

## 十、枚举定义

### 10.1 工单状态 (status)

| 状态 | 分类 | 说明 |
|------|------|------|
| IN_PROGRESS | 开放态 | 处理中（AI对话中/人工客服已接入） |
| WAITING | 开放态 | 等待人工（排队中） |
| RESOLVED | 关闭态 | 工单已关闭 |

**数据库兼容性说明**
```
当前数据库 TicketStatus 枚举已通过 migration 简化为三态：
- 原枚举: NEW, IN_PROGRESS, WAITING, RESOLVED, CLOSED
- 现枚举: IN_PROGRESS, WAITING, RESOLVED (migration: 20251124091500)

如果客服端或其他系统仍依赖旧状态值：
1. 数据库层保持现有枚举不变
2. 玩家端协议只暴露这 3 个状态
3. 后端做映射（如需要）
```

**注意：TicketStatus 与 SessionStatus 是两个独立枚举**
```
TicketStatus (工单状态):
  IN_PROGRESS  → 处理中
  WAITING      → 等待人工
  RESOLVED     → 已关闭

SessionStatus (会话状态，仅后端/客服端使用):
  PENDING      → 待处理
  QUEUED       → 排队中
  IN_PROGRESS  → 进行中
  CLOSED       → 已结束

玩家端只关心 TicketStatus，不需要感知 SessionStatus。
后端代码中的 session.status='CLOSED' 是会话关闭，与工单状态无关。
```

### 10.2 关闭原因 (closeReason)

| 值 | 说明 |
|-----|------|
| RESOLVED | 问题已解决 (客服标记) |
| MANUAL_PLAYER | 玩家手动关闭 |
| MANUAL_AGENT | 客服手动关闭 |
| AUTO_TIMEOUT | 超时自动关闭 |
| AUTO_CLOSED_BY_NEW_TICKET | 玩家发起新工单导致自动关闭 |
| DATA_CLEANUP | 数据清理 |

### 10.3 消息发送者类型 (senderType)

| 值 | 说明 |
|-----|------|
| PLAYER | 玩家 |
| AI | AI机器人 |
| AGENT | 人工客服 |
| SYSTEM | 系统消息 |

### 10.4 路由模式 (routeMode)

| 值 | 说明 |
|-----|------|
| AI | AI首答，可转人工 (默认) |
| HUMAN | 直接排队人工，跳过AI |

---

## 十一、错误码汇总

| 错误码 | 说明 |
|--------|------|
| INVALID_SIGN | 签名验证失败 |
| EXPIRED_REQUEST | 请求已过期 (ts超过5分钟) |
| DUPLICATE_NONCE | 重复请求(防重放) |
| GAME_NOT_FOUND | 游戏不存在 |
| GAME_DISABLED | 游戏已禁用 |
| API_DISABLED | 玩家API已禁用 |
| TICKET_NOT_FOUND | 工单不存在 |
| TICKET_CLOSED | 工单已关闭(不可恢复) |
| TICKET_NOT_YOURS | 工单不属于当前用户 |
| ISSUE_TYPE_REQUIRED | 问题类型必填 |
| CONFIRM_CLOSE_REQUIRED | 需确认关闭旧工单 |
| INVALID_TOKEN | WebSocket Token无效 |
| FILE_TOO_LARGE | 文件过大 |
| INVALID_FILE_TYPE | 文件类型不支持 |
| NO_TICKET_BOUND | 未绑定工单（需先 ticket:create 或 ticket:resume） |
| READ_ONLY_TICKET | 只读工单（已关闭，不可发消息） |
| INTERNAL_ERROR | 服务器内部错误 |

---

## 十二、Unity WebView 配置要求

### 12.1 权限配置

**Android (AndroidManifest.xml)**
```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />  <!-- Android 13+ -->
```

**iOS (Info.plist)**
```xml
<key>NSPhotoLibraryUsageDescription</key>
<string>用于上传图片到客服</string>
```

### 12.2 UniWebView 配置

```csharp
webView.SetAllowFileAccessFromFileURLs(true);
webView.SetAllowUniversalAccessFromFileURLs(true);

// 处理文件选择
webView.OnFileChooser += (view, openPanel) => {
    return true; // 由 UniWebView 处理
};
```

---

## 十三、图片上传实现

### 13.1 前端压缩（含 HEIC 处理）

```typescript
import imageCompression from 'browser-image-compression';
import heic2any from 'heic2any';

async function compressImage(file: File): Promise<File> {
  let processedFile = file;

  // HEIC/HEIF 转换（iOS 常用格式）
  if (file.type === 'image/heic' || file.type === 'image/heif' ||
      file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')) {
    try {
      const blob = await heic2any({ blob: file, toType: 'image/jpeg', quality: 0.9 });
      processedFile = new File([blob as Blob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), {
        type: 'image/jpeg'
      });
    } catch (e) {
      console.warn('[Upload] HEIC 转换失败，尝试直接上传:', e);
      // 转换失败时直接上传原文件，让后端处理
    }
  }

  // 压缩
  const options = {
    maxSizeMB: 2,
    maxWidthOrHeight: 1920,
    useWebWorker: true,
    fileType: 'image/jpeg'
  };
  return await imageCompression(processedFile, options);
}
```

### 13.2 上传流程

```typescript
async function uploadImage(file: File): Promise<string> {
  // 1. 压缩（含 HEIC 转换）
  const compressed = await compressImage(file);

  // 2. 构建 FormData
  const formData = new FormData();
  formData.append('file', compressed);

  // 3. 上传（使用 uploadToken 鉴权）
  const response = await fetch('/api/player/upload', {
    method: 'POST',
    headers: {
      'X-Upload-Token': uploadToken  // connect 返回的 uploadToken
    },
    body: formData
  });

  const result = await response.json();
  if (!result.result) {
    throw new Error(result.error || '上传失败');
  }
  return result.data.url;
}
```

### 13.3 后端 HEIC 转码（兜底）

```typescript
// 使用 sharp 库处理 HEIC（后端兜底）
import sharp from 'sharp';

async function processUploadedImage(buffer: Buffer, mimeType: string): Promise<Buffer> {
  // 统一转换为 JPEG
  return sharp(buffer)
    .jpeg({ quality: 85 })
    .toBuffer();
}

// 注：需要安装 sharp 和 libvips（支持 HEIC 解码）
// npm install sharp
// 服务器需安装 libvips: apt-get install libvips
```

---

## 十四、验收用例

| 序号 | 场景 | 预期结果 |
|-----|------|---------|
| 1 | 首次打开客服，无旧工单 | 显示问题分类列表 + bootstrapMessages |
| 2 | 有旧工单，选择继续咨询 | 恢复旧工单，显示历史消息 |
| 3 | 有旧工单，选择新问题 | 弹出确认框 |
| 4 | 确认关闭旧工单后新建 | 新工单成功，旧工单关闭 |
| 5 | 发送文本消息 | 收到 message:ack + AI 回复 |
| 6 | 发送消息后断线重发 | 相同 clientMsgId 返回相同 ack（幂等） |
| 7 | 上传 JPEG 图片 | 图片发送成功 |
| 8 | 上传 HEIC 图片（iOS） | 前端转 JPEG 或后端转码，上传成功 |
| 9 | 请求转人工（有客服在线） | 进入排队 |
| 10 | 请求转人工（无客服在线） | 提示无客服在线 |
| 11 | 排队中位置变化 | 实时更新排队位置 |
| 12 | 客服接入 | 显示客服信息 |
| 13 | 玩家关闭工单 | 工单状态变为 RESOLVED |
| 14 | 恢复已关闭工单 | 只读模式，可查看历史，不可发消息 |
| 15 | 断线后重连 | 恢复之前状态 |
| 16 | 同一玩家第二个连接 | 第一个连接被踢 |
| 17 | 签名过期 | 返回 EXPIRED_REQUEST |
| 18 | 重复 nonce | 返回 DUPLICATE_NONCE |
| 19 | uploadToken 过期 | 返回 INVALID_TOKEN，需重新 connect |

---

## 十五、配置项

```env
# 客服服务器配置
WS_URL=wss://cs.example.com                # WebSocket 地址
UPLOAD_DIR=/data/uploads                    # 上传文件目录
UPLOAD_MAX_SIZE=5242880                     # 最大文件大小 (5MB)

# 玩家 API 配置
PLAYER_API_WS_TOKEN_TTL=3600                # wsToken 有效期(秒) - 1小时
PLAYER_API_UPLOAD_TOKEN_TTL=600             # uploadToken 有效期(秒) - 10分钟
PLAYER_API_NONCE_TTL=300                    # Nonce 去重有效期(秒)
PLAYER_API_TIME_TOLERANCE=300000            # 时间戳容差(毫秒)
PLAYER_API_MSG_DEDUP_TTL=300                # 消息去重窗口(秒)
```

---

## 十六、安全加固建议

### 16.1 IP 白名单（可选）

如果游戏服务器 IP 固定，可以配置白名单：

```nginx
location /api/player/ {
    allow 10.0.0.0/8;
    allow 游戏服务器IP;
    deny all;
}
```

### 16.2 限流

```
建议对 /api/player/connect 和 /api/player/upload 做限流：
- connect: 每 IP 每分钟 60 次
- upload: 每用户每分钟 10 次
```

### 16.3 文件安全

```
- 校验文件 MIME type 和文件头
- 图片重新编码（防止恶意代码）
- 使用随机文件名
- 不暴露原始文件路径
```
