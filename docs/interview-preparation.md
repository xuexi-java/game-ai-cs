# AI 智能客服系统 - 面试准备文档

> 周末学习指南：请认真阅读并理解每个部分，能用自己的话复述出来

---

## 一、技术栈全貌

### 1.1 后端技术栈

| 技术 | 是什么 | 为什么用 | 面试怎么说 |
|------|--------|----------|------------|
| **NestJS** | Node.js 的企业级后端框架 | 模块化架构、依赖注入、装饰器模式，和 Spring Boot 设计理念相似 | "NestJS 提供了类似 Spring 的架构，有依赖注入、模块化、AOP 等企业级特性" |
| **TypeScript** | JavaScript 的超集，增加了类型系统 | 类型安全、IDE 智能提示、减少运行时错误 | "TypeScript 提供编译时类型检查，提前发现错误" |
| **PostgreSQL** | 关系型数据库 | 功能丰富、支持 JSON、事务可靠 | "PostgreSQL 支持复杂查询和 JSON 字段，适合业务逻辑复杂的系统" |
| **Prisma** | 现代 ORM 框架 | 类型安全、自动生成迁移、查询语法简洁 | "Prisma 提供类型安全的数据库操作，Schema 即代码，自动生成迁移" |
| **Redis** | 内存数据库/缓存 | 高性能、支持多种数据结构、适合队列和缓存 | "Redis 用于会话缓存、排队队列、分布式限流" |
| **Socket.IO** | WebSocket 库 | 实时双向通信、自动降级、房间管理 | "Socket.IO 实现客服和玩家的实时消息推送" |
| **JWT** | JSON Web Token | 无状态认证、适合分布式系统 | "使用 JWT 实现无状态认证，Token 包含用户信息，服务端无需存储会话" |

### 1.2 前端技术栈

| 技术 | 是什么 | 为什么用 |
|------|--------|----------|
| **React** | 前端 UI 框架 | 组件化、虚拟 DOM、生态丰富 |
| **Vite** | 构建工具 | 快速冷启动、热更新快 |
| **Zustand** | 状态管理库 | 轻量、API 简洁、比 Redux 简单 |
| **Ant Design** | UI 组件库 | 企业级组件、开箱即用 |

### 1.3 NestJS vs Next.js（必须区分！）

```
⚠️ 这两个名字很像但完全不同！

NestJS (你的项目用的)
├── 类型：后端框架
├── 作用：写 API 接口、业务逻辑
├── 类似：Java Spring Boot、Python Django
└── 特点：依赖注入、模块化、装饰器

Next.js (不是你用的)
├── 类型：前端框架
├── 作用：React 服务端渲染 (SSR)
├── 类似：Nuxt.js (Vue 版)
└── 特点：SSR、SSG、API Routes
```

---

## 二、核心业务概念

### 2.1 三个核心实体的关系

```
┌─────────────────────────────────────────────────────┐
│                      Ticket (工单)                    │
│  • 代表玩家的一次问题反馈                              │
│  • 包含：游戏信息、问题描述、附件                       │
│  • 一个工单可以有多个会话                              │
└─────────────────────────────────────────────────────┘
                         │
                         │ 1:N (一个工单可有多个会话)
                         ▼
┌─────────────────────────────────────────────────────┐
│                     Session (会话)                    │
│  • 代表一次客服对话                                   │
│  • 可以是 AI 会话或人工会话                           │
│  • 状态：等待中 → 排队中 → 进行中 → 已关闭             │
└─────────────────────────────────────────────────────┘
                         │
                         │ 1:N (一个会话有多条消息)
                         ▼
┌─────────────────────────────────────────────────────┐
│                     Message (消息)                    │
│  • 会话中的每条消息                                   │
│  • 发送者类型：玩家 / AI / 客服 / 系统                 │
│  • 消息类型：文本 / 图片 / 系统通知                    │
└─────────────────────────────────────────────────────┘
```

### 2.2 为什么要分 Ticket 和 Session？

**面试回答：**
> "工单(Ticket)代表玩家的一个问题，会话(Session)代表一次对话。同一个问题可能需要多次沟通，比如玩家先和 AI 聊，不满意转人工，这就是同一个工单下的两个会话。这样设计可以保留完整的沟通历史，也方便统计每个问题的处理过程。"

### 2.3 会话状态流转

```
PENDING (等待中)
    │
    ▼ 玩家开始咨询
QUEUED (排队中) ←───────┐
    │                   │
    ▼ 客服接入          │ 转人工
IN_PROGRESS (进行中) ───┘
    │
    ▼ 问题解决
CLOSED (已关闭)
```

---

## 三、核心业务流程

### 3.1 玩家完整使用流程

```
1. 玩家进入系统
        │
        ▼
2. 填写表单
   • 选择游戏
   • 选择区服
   • 填写游戏ID/角色名
   • 选择问题类型
   • 描述问题
   • 上传截图（可选）
        │
        ▼
3. 系统创建工单 (Ticket)
   • 生成唯一工单号
   • 根据问题类型判断紧急程度
        │
        ▼
4. 进入会话
   ┌─────────────────┬──────────────────┐
   │   问题类型判断    │                  │
   ▼                 ▼                  │
 AI 客服          直接人工              │
   │                 │                  │
   ▼                 ▼                  │
 AI 回答问题      进入排队               │
   │                 │                  │
   │ 不满意          │                  │
   ▼                 │                  │
 转人工 ─────────────┤                  │
   │                 │                  │
   ▼                 ▼                  │
        等待客服接入                     │
             │                          │
             ▼                          │
        客服处理问题                     │
             │                          │
             ▼                          │
        关闭会话 ────────────────────────┘
             │
             ▼
5. 满意度评价
```

### 3.2 AI 的两个作用点

**作用点 1：分流阶段**
- 玩家选择问题类型后，系统根据配置决定走 AI 还是人工
- AI 尝试解答常见问题（如：如何充值、如何改密码）
- 复杂问题或玩家不满意时转人工

**作用点 2：话术优化**
- 客服输入回复内容后，可以点击"AI 优化"
- AI 会改写内容，使表达更专业、更友好
- 客服可以选择使用优化后的内容或保持原内容

---

## 四、技术实现细节

### 4.1 实时通信 (WebSocket)

**为什么需要 WebSocket？**
> HTTP 是请求-响应模式，客户端不请求服务端就不能主动推送。客服系统需要实时收到新消息，所以用 WebSocket 实现双向通信。

**核心事件设计：**
```typescript
// 客户端 → 服务端
'joinSession'      // 加入会话房间
'sendMessage'      // 发送消息
'leaveSession'     // 离开会话

// 服务端 → 客户端
'newMessage'       // 新消息通知
'sessionUpdate'    // 会话状态变化
'queueUpdate'      // 排队位置更新
'agentJoined'      // 客服加入通知
```

**房间(Room)概念：**
```
Socket.IO 的 Room 机制：
• 每个会话是一个房间，房间名 = session_{sessionId}
• 玩家和客服加入同一个房间
• 发消息时广播给房间内所有人
• 这样就不用管理具体的 socket 连接
```

### 4.2 排队机制

**为什么需要排队？**
> 客服数量有限，多个玩家同时转人工时需要排队等待。

**优先级计算因素：**
```
优先级分数 (0-100) =
    问题类型权重 (如充值问题 +30)
  + 等待时间加成 (每分钟 +1)
  + VIP 玩家加成
  + 紧急程度标记
```

**Redis 队列实现：**
```
使用 Redis 的 Sorted Set (有序集合)
• 分数 = 优先级分数
• 值 = sessionId
• 自动按优先级排序
• 客服取最高优先级的会话
```

### 4.3 Dify AI 集成

**什么是 Dify？**
> Dify 是一个 LLM 应用开发平台，可以快速创建 AI 对话应用。我们通过 API 调用 Dify，不需要自己训练模型。

**调用流程：**
```
玩家发消息
    │
    ▼
后端收到消息，存入数据库
    │
    ▼
调用 Dify API，传入：
  • 用户消息
  • 对话历史 (conversation_id)
  • 游戏上下文
    │
    ▼
Dify 返回 AI 回复
    │
    ▼
存入数据库，通过 WebSocket 推送给玩家
```

### 4.4 数据库设计要点

**核心表结构：**
```sql
-- 游戏表：支持多游戏
Game (id, name, icon, difyApiKey, enabled)

-- 工单表：玩家问题
Ticket (id, ticketNo, gameId, playerId, description, status, priority)

-- 会话表：对话记录
Session (id, ticketId, agentId, status, queuePosition, priorityScore)

-- 消息表：聊天内容
Message (id, sessionId, senderType, content, messageType)

-- 用户表：客服账号
User (id, username, password, role, isOnline)
```

**索引优化：**
```sql
-- 常用查询需要索引
Ticket: [status, createdAt]     -- 按状态查询工单列表
Session: [status, priorityScore] -- 排队列表查询
Message: [sessionId, createdAt]  -- 获取会话消息
```

---

## 五、常见面试问题及参考答案

### Q1: 请介绍一下这个项目

**参考答案：**
> 这是一个 AI 智能客服系统，主要服务于游戏玩家。系统的核心目标是提高客服效率。
>
> AI 在系统中有两个作用：
> 1. 分流阶段：根据问题类型，简单问题由 AI 直接解答，复杂问题转人工
> 2. 话术优化：客服回复时可以用 AI 优化表达，使回复更专业
>
> 技术上，后端用 NestJS + TypeScript，数据库是 PostgreSQL，用 Redis 做缓存和队列，WebSocket 实现实时通信，前端是 React + Ant Design。

### Q2: 为什么选择 NestJS？

**参考答案：**
> NestJS 是一个企业级 Node.js 框架，它的设计理念和 Spring Boot 很像：
> - 模块化架构，代码组织清晰
> - 内置依赖注入，方便单元测试
> - 装饰器语法，代码简洁
> - TypeScript 原生支持，类型安全
>
> 另外，前端用 React + TypeScript，后端也用 TypeScript，可以共享类型定义，减少前后端联调的问题。

### Q3: WebSocket 是怎么实现的？

**参考答案：**
> 我们用 Socket.IO 实现 WebSocket 通信。
>
> 核心设计是"房间"机制：每个会话是一个房间，玩家和客服加入同一个房间。发消息时广播给房间内所有人。
>
> 主要事件包括：
> - joinSession：加入会话房间
> - sendMessage：发送消息
> - newMessage：新消息通知
> - queueUpdate：排队位置更新
>
> 断线重连方面，Socket.IO 会自动尝试重连，重连后客户端重新加入之前的房间。

### Q4: 排队是怎么实现的？

**参考答案：**
> 排队用 Redis 的 Sorted Set 实现。
>
> 每个等待的会话作为一个元素，优先级分数作为 score。Sorted Set 自动按 score 排序。
>
> 优先级分数的计算考虑：
> - 问题类型权重（如充值问题优先级更高）
> - 等待时间（等得越久分数越高）
> - 是否 VIP 玩家
>
> 客服接单时，从队列取最高优先级的会话。同时通过 WebSocket 通知其他玩家排队位置变化。

### Q5: 如何保证消息不丢失？

**参考答案：**
> 消息可靠性从几个层面保证：
>
> 1. **持久化优先**：消息先存数据库，再通过 WebSocket 推送
> 2. **消息确认**：Socket.IO 有 ack 机制，可以确认消息送达
> 3. **离线消息**：用户重新上线后，从数据库拉取未读消息
> 4. **重连恢复**：断线重连后重新加入房间，获取期间的消息

### Q6: AI 是怎么集成的？

**参考答案：**
> 我们用的是 Dify 平台，它是一个 LLM 应用开发平台，提供 API 接口。
>
> 调用流程：
> 1. 玩家发消息，后端先存数据库
> 2. 调用 Dify API，传入消息内容和对话 ID
> 3. Dify 返回 AI 回复
> 4. 存入数据库，WebSocket 推送给玩家
>
> 每个游戏可以配置不同的 Dify 应用，这样不同游戏的 AI 可以有不同的知识库和回答风格。

### Q7: 遇到过什么技术难点？

**参考答案（选择 1-2 个讲）：**

**难点 1：会话状态管理**
> 会话有多种状态（等待、排队、进行中、已关闭），状态流转逻辑复杂。比如玩家关闭页面、客服下线、超时未响应等情况都要处理。我们用状态机的思想，明确定义每个状态可以转换到哪些状态，避免出现非法状态。

**难点 2：排队优先级动态调整**
> 玩家等待时间越长，优先级应该越高，但不能每秒都更新 Redis。我们的做法是把入队时间记录下来，计算优先级时动态加上等待时间加成，这样既保证公平性，又减少 Redis 写入。

**难点 3：WebSocket 连接管理**
> 玩家可能开多个标签页，或者断线重连，需要正确管理连接。我们用 Socket.IO 的房间机制，不直接管理 socket 连接，而是管理房间成员，简化了逻辑。

### Q8: 系统的并发能力怎么样？

**参考答案：**
> 目前主要靠以下手段保证性能：
>
> 1. **Redis 缓存**：热点数据（如游戏配置、快捷回复）缓存在 Redis
> 2. **数据库索引**：常用查询都建了复合索引
> 3. **连接池**：数据库和 Redis 都用连接池，避免频繁建连接
> 4. **限流**：用 Redis 实现分布式限流，防止恶意请求
>
> 具体并发数没有做过压测（如果真的没做过就诚实说），但架构上预留了扩展空间，后续可以通过负载均衡部署多个后端实例。

---

## 六、代码阅读指南

### 6.1 建议阅读顺序

```
第一天：理解项目结构
├── backend/src/app.module.ts        -- 看有哪些模块
├── backend/prisma/schema.prisma     -- 理解数据库设计
└── backend/src/main.ts              -- 启动入口

第二天：核心业务流程
├── backend/src/ticket/              -- 工单模块
├── backend/src/session/             -- 会话模块（最重要）
└── backend/src/message/             -- 消息模块

第三天：技术组件
├── backend/src/websocket/           -- WebSocket 实现
├── backend/src/dify/                -- AI 集成
└── backend/src/queue/               -- 队列管理

第四天：辅助功能
├── backend/src/auth/                -- 认证授权
├── backend/src/quick-reply/         -- 快捷回复
└── backend/src/common/              -- 通用组件
```

### 6.2 重点文件（必须理解）

| 文件 | 重要程度 | 内容 |
|------|----------|------|
| `prisma/schema.prisma` | ⭐⭐⭐⭐⭐ | 数据库表结构，理解业务的基础 |
| `session/session.service.ts` | ⭐⭐⭐⭐⭐ | 核心业务逻辑，会话管理 |
| `websocket/websocket.gateway.ts` | ⭐⭐⭐⭐ | WebSocket 事件处理 |
| `ticket/ticket.service.ts` | ⭐⭐⭐⭐ | 工单管理逻辑 |
| `dify/dify.service.ts` | ⭐⭐⭐ | AI 调用逻辑 |

---

## 七、周末学习计划

### Day 1（周六上午）：技术栈理论
- [ ] 理解 NestJS 和 Next.js 的区别
- [ ] 了解 NestJS 的核心概念（模块、控制器、服务、依赖注入）
- [ ] 了解 Prisma 的基本用法

### Day 1（周六下午）：数据库设计
- [ ] 阅读 `prisma/schema.prisma`
- [ ] 画出 ER 图（实体关系图）
- [ ] 理解 Ticket、Session、Message 的关系

### Day 2（周日上午）：核心业务代码
- [ ] 阅读 `session/session.service.ts`（挑重点方法看）
- [ ] 阅读 `websocket/websocket.gateway.ts`
- [ ] 理解会话创建、消息发送、转人工的流程

### Day 2（周日下午）：面试准备
- [ ] 用自己的话复述项目介绍
- [ ] 准备 3 个技术难点的回答
- [ ] 找人模拟面试（或对着镜子讲）

---

## 八、自我检测清单

完成学习后，看看这些问题能否回答：

### 基础题（必须会）
- [ ] NestJS 是什么？和 Next.js 有什么区别？
- [ ] 项目用了哪些技术？每个技术的作用是什么？
- [ ] 工单和会话是什么关系？为什么要分开？
- [ ] 玩家使用流程是怎样的？

### 进阶题（尽量会）
- [ ] WebSocket 是怎么实现的？用了什么设计？
- [ ] 排队是怎么实现的？优先级怎么计算？
- [ ] AI 是怎么集成的？
- [ ] 有哪些数据库索引？为什么这样设计？

### 深入题（加分项）
- [ ] 遇到过什么技术难点？怎么解决的？
- [ ] 如果并发量增大，系统该怎么扩展？
- [ ] 消息可靠性是怎么保证的？

---

## 九、最后的建议

1. **诚实最重要**：不会就说不会，不要编造
2. **理解比记忆重要**：能用自己的话说出来
3. **准备 1-2 个亮点**：技术难点、优化经验
4. **承认 AI 辅助开发是可以的**：但要说清楚你理解了代码

**面试话术示例：**
> "这个项目开发过程中我使用了 AI 编程工具辅助，但我对整体架构和核心代码都有深入理解。比如 WebSocket 这块，我可以详细讲一下实现方案..."

加油！有问题随时问我。
